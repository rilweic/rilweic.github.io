<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Dockerfile入门文章]]></title>
      <url>/2017/04/14/Dockerfile%E5%85%A5%E9%97%A8%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="Dockerfile构建Tomcat"><a href="#Dockerfile构建Tomcat" class="headerlink" title="Dockerfile构建Tomcat"></a>Dockerfile构建Tomcat</h2><p><span class="s1"><strong>1、什么是Docker？</strong></span></p>
<p><span class="s1">Docker是个新生的事物，概念类似虚拟化。简单来说，Docker就是一个应用程序执行容器，类似虚拟机的概念。但是与虚拟化不同的是有以下几点：</span></p>
<p><span class="s1"><strong>A) </strong>虚拟化系统一般都是指操作系统镜像，比较复杂，称为“系统”；而docker开源而且轻量，称为“容器”，单个容器适合部署少量应用。</span><br><a id="more"></a><br><span class="s1"><strong>B) </strong>传统的虚拟化技术在构建系统的时候较为复杂，需要大量的人力；而docker可以通过Dockfile来构建整个容器，重启和构建,而且速度很快。更重要的是Dockfile可以手动编写，这样开发人员可以通过发布Dockfile来指导系统环境和依赖，这样对于持续交付十分有利。</span></p>
<p><span class="s1"><strong>C) </strong>传统的虚拟化技术使用快照来保存状态；而docker在保存状态上不仅更为轻便和低成本，而且引入了类似源代码管理机制，将容器的快照历史版本一一记录，切换成本很低。</span></p>
<p><span class="s1"><strong>2、如何快速通过Dockerfile构建镜像</strong></span></p>
<p><span class="s1"><strong>首要条件</strong>：你的电脑得先安装docker环境。</span></p>
<p><span class="s1">如何安装docker就不在此赘述了，这不是本文讨论的重点。接下来，通过做一个Tomcat镜像来教大家如何使用DockerFile来构建应用。</span></p>
<p><span class="s1">1、创建一个Dockerfile</span></p>
<p><span class="s1">Dockerfile命名必须为“Dockerfile”,docker构建时会找指定目录中的Dockerfile来进行构建。</span></p>
<p><span class="s1">2、编写Dockerfile</span></p>
<p><span class="s1">1)首先，我们需要指定一个基础镜像，为了方便立即，这里从Ubuntu镜像开始。</span></p>
<blockquote>
<p><span class="s1"><strong>FROM ubuntu:14.04</strong></span></p>
</blockquote>
<p><span class="s1">通过FROM指令，docker编译程序能够知道在哪个基础镜像执行来进行编译。所有的Dockerfile都必须以FROM指令开始。通过这句，我们相当于有了一个最基本的ubuntu系统。</span></p>
<p><span class="s1">2）其他环境配置。</span></p>
<p><span class="s1">我们可以像这样指定Dockerfile的作者。</span></p>
<blockquote>
<p><span class="s1"><strong>MAINTAINER example &lt;example@goodrain.com&gt;</strong></span></p>
</blockquote>
<p><span class="s1">另外我们需要指定时区，否则我们做出的镜像可能会跟当前时间不符。</span></p>
<blockquote>
<p><span class="s1"><strong>RUN echo “Asia/Shanghai” &gt; /etc/timezone;dpkg-reconfigure -f noninteractive tzdata</strong></span></p>
</blockquote>
<p><span class="s1">我们平时在自己电脑上如何安装Tomcat就可以在docker容器中如何安装。</span></p>
<p><span class="s1">3）Tomcat必要软件安装。</span></p>
<p><span class="s1">我们此时使用的Ubuntu系统其实是很简陋的系统，上面很多系统都没有。所以我先安装一些必要的软件。</span></p>
<blockquote>
<p><span class="s1"><strong>RUN apt-get update &amp;&amp; apt-get install -y curl vim net-tools &amp;&amp; \</strong></span></p>
<p><span class="s1"><strong> rm -rf /var/lib/apt/lists/* &amp;&amp; mkdir -p /app</strong></span></p>
</blockquote>
<p><span class="s1"><strong>RUN</strong>指令用来在docker的编译环境中运行指定命令。这里我安装了<strong>curl、vim、net-tools。</strong>其中curl用来获取java和tomcat的安装包，vim和net-tools用来调试。并创建/app目录</span></p>
<p><span class="s1">4）指定工作目录</span></p>
<p><span class="s1">上一步中创建了 /app目录，使用 <strong>WORKDIR /app </strong>可以将工作目录定位到/app 目录下</span></p>
<p><span class="s1">5）获取安装软件</span></p>
<p><span class="s1"><span class="Apple-converted-space">  </span>第3)安装完成了curl,我们使用curl工具来获取安装包。</span></p>
<blockquote>
<p><span class="s1"><strong>RUN<span class="Apple-converted-space">  </span>curl -L ‘<a href="http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz" target="_blank" rel="external">http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz</a>‘ -H ‘Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile’ | tar -xz \</strong></span></p>
<p><span class="s1"><strong><span class="Apple-converted-space">    </span>&amp;&amp; curl -L ‘<a href="http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz" target="_blank" rel="external">http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz</a>‘ | tar -xz</strong></span></p>
</blockquote>
<p><span class="s1">以上命令将会从指定地址下载安装包，并解压到当前目录（上一步我们指定了工作空间为/app，所以会解压到此目录下）</span></p>
<p><span class="s1">6）指定运行脚本</span></p>
<p><span class="s1">截止到上一步，我们已经将需要的准备工作都做好了，剩下的还有Java环境变量的设置，Tomcat环境变量设置（非必须）和Tomcat的启动。</span></p>
<blockquote>
<p><span class="s1"><strong>COPY tomcat7.sh /app/tomcat7.sh</strong></span></p>
<p><span class="s1"><strong>RUN chmod +x /app/tomcat7.sh</strong></span></p>
</blockquote>
<p><span class="s1">上面的两行命令会将与Dockerfile同级目录的tomcat7.sh文件上传到docker容器中的/app目录下，并且给该文件赋予可执行的权限。</span></p>
<p><span class="s1">看一眼该脚本的内容便一目了然了。</span></p>
<blockquote>
<p><span class="s1"> <strong># Java环境变量配置</strong></span></p>
<p><span class="s1"><strong> export JAVA_HOME=/app/jdk1.7.0_65</strong></span></p>
<p><span class="s1"><strong> export PATH=$JAVA_HOME/bin:$PATH</strong></span></p>
<p><span class="s1"><strong> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</strong></span></p>
<p><span class="s1"><strong> # Tomcat环境变量配置</strong></span></p>
<p><span class="s1"><strong> export TOMCAT_HOME=/app/apache-tomcat-7.0.8</strong></span></p>
<p><span class="s1"><strong> export PATH=$TOMCAT_HOME/bin:$PATH</strong></span></p>
<p><span class="s1"><strong> # 启动 Tomcat</strong></span></p>
<p><span class="s1"><strong> exec $TOMCAT_HOME/bin/catalina.sh run</strong></span></p>
</blockquote>
<p><span class="s1">7) 指定端口</span></p>
<blockquote>
<p><span class="s1"><strong>EXPOSE 8080</strong></span></p>
</blockquote>
<p><span class="s1">通常情况下，Tomcat启动后会监听8080端口，在容器中也一样。</span></p>
<p><span class="s1">EXPOSE指令用于标明，这个镜像中的应用将会侦听某个端口，并且希望能将这个端口映射到主机的网络界面上</span></p>
<p><span class="s1">8）指定脚本的运行</span></p>
<p><span class="s1">至此，我们要做的准备工作就做完了，但是还差一步，运行我们在第6步创建的脚本，使用下面的这条命令即可。</span></p>
<blockquote>
<p><span class="s1"><strong>ENTRYPOINT [“/app/tomcat7.sh”]</strong></span></p>
</blockquote>
<p><span class="s1">ENTRYPOINT<span class="Apple-converted-space">  </span>用于标明一个镜像作为容器运行时，最后要执行的程序或命令。</span></p>
<p><span class="s1">这样我们简单的一个Tomcat的Dockerfile就编写完成了。</span></p>
<p><span class="s1">3.构建镜像</span></p>
<p><span class="s1">进入Dockerfile所在目录，运行命令 <strong>docker build -t mytomcat .</strong> (注意最后有个点用来表示当前目录。初次构建速度会比较慢，需要多等一会) </span></p>
<p><span class="s1">出现如下信息就构建成功了 </span></p>
<p><span class="s1">4.运行docker容器</span></p>
<blockquote>
<p><span class="s1"><strong>docker run -i -t -p 5000:8080 mytom</strong></span></p>
</blockquote>
<p><span class="s1">其中docker run 用于运行一个容器 。</span></p>
<p><span class="s1"><strong> -t</strong> 在容器指定一个伪终端或者终端;</span></p>
<p><span class="s1"> <strong>-i</strong> 进行命令交互;</span></p>
<p><span class="s1"> <strong>-p</strong> 匹配镜像内的网络端口号,即我们可以通过宿主机中访问5000端口来达到访问容器8080端口的目的。</span></p>
<p><span class="s1">5.查看构建好的镜像和运行的容器</span></p>
<p><span class="s1"><strong>docker images<span class="Apple-converted-space">  </span></strong>#查看镜像 </span></p>
<p><span class="s1"><strong>docker ps -a </strong>#查看所有的容器 </span></p>
<p><span class="s1">6.查看服务是否运行</span></p>
<p><span class="s1">在宿主机中我们输入localhost:5000访问，出现如下界面，表示Tomcat成功运行。 </span></p>
<p><span class="s1">至此，我们就成功的创建了一个Tomcat镜像了，当然这里只是为了简单演示，所以镜像做的比较简单，官方的Tomcat镜像比这复杂的多，在熟悉了Dockerfile后可以去看看官方的做法。</span></p>
<p><span class="s1">7.其他</span></p>
<p><span class="s1">在做镜像的时候有那么多步骤，根本不可能一次将所有的步骤完成，所以，这里教给大家一个小技巧。</span></p>
<p><span class="s1">在编写完Dockerfile到第二步的时候，其实可以先使用一个脚本先运行着，然后进入容器内部进行操作。笔者在编写Dockerfile时先使用如下命令</span></p>
<blockquote>
<p><span class="s1"><strong> COPY run.sh /app/run.sh</strong></span></p>
<p><span class="s1"><strong> RUN chmod +x /app/run.sh</strong></span></p>
<p><span class="s1"><strong> ENTRYPOINT [“/app/run.sh”]</strong></span></p>
</blockquote>
<p><span class="s1">run.sh脚本的内容如下</span></p>
<blockquote>
<p><span class="s1"><strong> #!/bin/bash</strong></span></p>
<p><span class="s1"><strong> sleep 15</strong></span></p>
<p><span class="s1"><strong> while true</strong></span></p>
<p><span class="s1"><strong> do</strong></span></p>
<p><span class="s1"><strong><span class="Apple-converted-space">     </span>echo “true”</strong></span></p>
<p><span class="s1"><strong><span class="Apple-converted-space">     </span>sleep 180</strong></span></p>
<p><span class="s1"><strong> done</strong></span></p>
</blockquote>
<p><span class="s1">其实就是一段死循环代码代替原有的tomcat7.sh,接着就可以build和run我们的容器了。容器运行起来后使用<strong>docker exec -it container_id bash </strong>进入docker容器。此时就和我们平时装软件的方式一样了，做完一个步骤，在Dockerfile中记录一条，这样Dockerfile也就做出来了。(ps:<strong>exit</strong>退出容器。)</span></p>
<p><span class="s1">特别注意的一点，如果做好镜像以后，在镜像中有需要保存的数据（持久化目录）需要我们在Dockerfile中指定持久化目录。为了能够保存（持久化）数据以及共享容器间的数据，Docker提出了Volume的概念。简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。并且我们运行容器的时候需要使用使用 -v 来声明Volume，如：</span></p>
<blockquote>
<p><span class="s1"><strong>docker run -it -v /home/dock/logs:/usr/logs tomcat /bin/bash</strong></span></p>
</blockquote>
<p><span class="s1">冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径，这样容器内更改的数据就被写到宿主机上了。</span></p>
<p><span class="s1">拥有了Tomcat服务器后，就可以跑写好的java-web程序了，如何运行java-web程序就不在此详述了，跟普通运行java-web程序一样。</span></p>
<p><span class="s1">同样的，如果你有一个web应用，将其放入Docker容器中，写好Dockerfile，构建好应用运行需要的环境后，就可以很快的使用应用了。</span></p>
<p><span class="s1">Dockerfile源码已放到好雨的github公共仓库了。地址：<a href="https://github.com/goodrain-apps/tomcat-demo" target="_blank" rel="external"><span class="s2">https://github.com/goodrain-apps/tomcat-demo</span></a> 。上面有很多使用Dockerfile构建的项目。可以方便大家学习。</span></p>
<p><span class="s1">最后补充一点，好雨云平台目前支持java，php,python等多种语言的应用，不用自己构建具体环境，可以直接从源码进行构建，十分方便。以上说的Dockerfile也是支持的。如果有写好的程序想要跑起来可以参照好雨官方文档进行部署。</span></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dockerfile </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WordPress 配置]]></title>
      <url>/2017/03/18/WordPress-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="wp邮件配置"><a href="#wp邮件配置" class="headerlink" title="wp邮件配置"></a>wp邮件配置</h2><ul>
<li><p>安装wordpress</p>
<p>按照文档安装，解压wordpress安装包时要讲wordpress安装包的权限改为apache，因为apache的默认使用用户和用户组为apache，详情可以参考apache服务器配置文件httpd.conf.</p>
</li>
</ul>
<a id="more"></a>
<blockquote>
<p>注意wordpress安装需要自行创建数据库</p>
</blockquote>
<ul>
<li><p>配置邮件服务器</p>
</li>
<li><p>安装sendmail服务 yum install sendmail,然后启动。 service sendmail start (后来证明不安装也可以)</p>
</li>
<li>安装wp-mail-smtp插件（这样方便，因为自身所带的邮件服务无法发送）并进行配置。如图</li>
</ul>
<p><img src="/images/pasted-2.png" alt="upload successful"></p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<blockquote>
<p>注意：password部分为邮件客户端的授权码，使用插件发送时为了安全需要授权码，详情参照<a href="http://jingyan.baidu.com/article/495ba841ecc72c38b30ede38.html" target="_blank" rel="external">here</a></p>
</blockquote>
<p>最后使用测试发一封邮件就OK了</p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客配置 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 有关网络的一篇文章]]></title>
      <url>/2017/03/15/Docker-%E6%9C%89%E5%85%B3%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h2 id="Docker-网络构造：Docker如何使用Linux-iptables-和-Interfaces"><a href="#Docker-网络构造：Docker如何使用Linux-iptables-和-Interfaces" class="headerlink" title="Docker 网络构造：Docker如何使用Linux iptables 和 Interfaces"></a>Docker 网络构造：Docker如何使用Linux iptables 和 Interfaces</h2><p><a href="http://securitynik.blogspot.ca/2016/12/docker-networking-internals-how-docker_16.html" target="_blank" rel="external">原文出处</a></p>
<p>我使用docker至今已有一段时间了，与绝大部分的人一样，我被docker强大的功能和易用性深深的折服。简单方便是docker的核心之一，它强大的功能被抽象成了非常简单的命令。当我在使用和学习docker的时候，我很想知道docker在后台都做了一些什么事情，特别是在网络这一块（我最感兴趣的一块）<br><a id="more"></a></p>
<p>我找到了很多关于创建和操作容器网络的文档，但是关于docker如何使网络工作的却没有那么多。 Docker广泛使用linux iptables和网桥接口，这篇文章是我如何用于创建容器网络的总结，大部分信息来自github上的讨论，演示文稿，以及我自己的测试。文章结尾我会给出我认为非常有用的资料链接。</p>
<p>我写这篇文章使用的是docker 1.12.3,但这不是作为对docker网络的全面描述，也不作为docker网络的介绍。我只希望这篇文章能给大家开拓视野，也非常感谢所有对文章错误，缺失的反馈和批评。</p>
<h3 id="Docker网络概览"><a href="#Docker网络概览" class="headerlink" title="Docker网络概览"></a>Docker网络概览</h3><p>Docker的网络建立在允许任何一方编写自己的网络驱动程序的容器网络模型（CNM）之上。这允许不同的网络类型可用于在docker引擎上运行的容器，并且容器可以同时连接到多个网络。除了各种第三方网络驱动程序可用，docker自带四个内置网络驱动程序：</p>
<ul>
<li><strong>Bridge</strong>: 这是启动容器的默认网络。通过docker主机上的网桥接口实现连接。 使用相同网桥的容器有自己的子网，并且可以相互通信（默认情况下）。</li>
<li><strong>Host</strong>:这个驱动程序允许容器访问docker主机自己的网络空间（容器将看到和使用与docker主机相同的接口）。</li>
<li><strong>Macvlan</strong>:此驱动程序允许容器直接访问主机的接口或子接口（vlan）。 它还允许中继链接。</li>
<li><strong>Overlay</strong>：此驱动程序允许在运行docker的多个主机（通常是docker群集群）上构建网络。 容器还具有自己的子网和网络地址，并且可以直接相互通信，即使它们在不同的物理主机上运行。</li>
</ul>
<p>Bridge和Overlay可能是最常用的网络驱动程序，在本文和下一篇文章中我将主要关注这两个驱动程序。</p>
<h4 id="Docker-Bridge-网络"><a href="#Docker-Bridge-网络" class="headerlink" title="Docker Bridge 网络"></a>Docker Bridge 网络</h4><p>在docker主机上运行的容器的默认网络是。 Docker在首次安装时创建一个名为“bridge”的默认网络。 我们可以列出所有docker网络来查看此网络 <code>docker network ls</code>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker network ls</div><div class="line"></div><div class="line">NETWORK ID          NAME                DRIVER              SCOPE</div><div class="line"><span class="number">3e8110</span>efa04a        bridge              bridge              <span class="built_in">local</span></div><div class="line">bb3cd79b9236        docker_gwbridge     bridge              <span class="built_in">local</span></div><div class="line"><span class="number">22849</span>c4d1c3a        host                host                <span class="built_in">local</span></div><div class="line"><span class="number">3</span>kuba8yq3c27        ingress             overlay             swarm</div><div class="line">ecbd1c6c193a        <span class="literal">none</span>                <span class="built_in">null</span>                <span class="built_in">local</span></div></pre></td></tr></table></figure>
<p>要检查其属性，运行<code>docker network inspect bridge</code></p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$ docker network inspect bridge</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"bridge"</span>,</div><div class="line">        <span class="string">"Id"</span>: <span class="string">"3e8110efa04a1eb0923d863af719abf5eac871dbac4ae74f133894b8df4b9f5f"</span>,</div><div class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span>,</div><div class="line">        <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</div><div class="line">        <span class="string">"EnableIPv6"</span>: false,</div><div class="line">        <span class="string">"IPAM"</span>: &#123;</div><div class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</div><div class="line">            <span class="string">"Options"</span>: null,</div><div class="line">            <span class="string">"Config"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"Subnet"</span>: <span class="string">"172.18.0.0/16"</span>,</div><div class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span></div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"Internal"</span>: false,</div><div class="line">        <span class="string">"Containers"</span>: &#123;&#125;,</div><div class="line">        <span class="string">"Options"</span>: &#123;</div><div class="line">            <span class="string">"com.docker.network.bridge.default_bridge"</span>: <span class="string">"true"</span>,</div><div class="line">            <span class="string">"com.docker.network.bridge.enable_icc"</span>: <span class="string">"true"</span>,</div><div class="line">            <span class="string">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="string">"true"</span>,</div><div class="line">            <span class="string">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">            <span class="string">"com.docker.network.bridge.name"</span>: <span class="string">"docker0"</span>,</div><div class="line">            <span class="string">"com.docker.network.driver.mtu"</span>: <span class="string">"1500"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"Labels"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>你还可以使用<code>docker network create</code>命令并指定选项<code>--driver bridge</code>创建自己的网络，例如<br><code>docker network create --driver bridge --subnet 192.168.100.0/24 --ip-range 192.168.100.0/ 24 my-bridge-network</code>创建另一个网桥网络，名称为<code>“my-bridge-network”</code>，子网为<code>192.168.100.0/24</code>。</p>
<h4 id="Linux-网桥接口"><a href="#Linux-网桥接口" class="headerlink" title="Linux 网桥接口"></a>Linux 网桥接口</h4><p>docker创建的每个网桥网络由docker主机上的网桥接口呈现。、 默认桥网络“bridge”通常具有与其相关联的接口docker0，并且使用docker network create命令创建的每个后续网桥网络将具有与其相关联的新接口。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ifconfig docker0</div><div class="line">docker0   Link <span class="string">encap:</span>Ethernet  HWaddr <span class="number">02</span>:<span class="number">42</span>:<span class="number">44</span>:<span class="number">88</span>:<span class="string">bd:</span><span class="number">75</span></div><div class="line">          inet <span class="string">addr:</span><span class="number">172.18</span><span class="number">.0</span><span class="number">.1</span>  <span class="string">Bcast:</span><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>  <span class="string">Mask:</span><span class="number">255.255</span><span class="number">.0</span><span class="number">.0</span></div><div class="line">          UP BROADCAST MULTICAST  <span class="string">MTU:</span><span class="number">1500</span>  <span class="string">Metric:</span><span class="number">1</span></div><div class="line">          RX <span class="string">packets:</span><span class="number">0</span> <span class="string">errors:</span><span class="number">0</span> <span class="string">dropped:</span><span class="number">0</span> <span class="string">overruns:</span><span class="number">0</span> <span class="string">frame:</span><span class="number">0</span></div><div class="line">          TX <span class="string">packets:</span><span class="number">0</span> <span class="string">errors:</span><span class="number">0</span> <span class="string">dropped:</span><span class="number">0</span> <span class="string">overruns:</span><span class="number">0</span> <span class="string">carrier:</span><span class="number">0</span></div><div class="line"><span class="symbol">          collisions:</span><span class="number">0</span> <span class="string">txqueuelen:</span><span class="number">0</span></div><div class="line">          RX <span class="string">bytes:</span><span class="number">0</span> (<span class="number">0.0</span> B)  TX <span class="string">bytes:</span><span class="number">0</span> (<span class="number">0.0</span> B)</div></pre></td></tr></table></figure></p>
<p>要找到与你创建的docker网络关联的linux接口，可以使用<code>ifconfig</code>列出所有接口，然后找到你指定了子网的接口，例如，我们想查看我们之前创建的网桥接口<code>my-bridge-network</code>我们可以这样：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ifconfig | grep <span class="number">192.168</span><span class="meta">.100</span>. -B <span class="number">1</span></div><div class="line">br-e6bc7d6b75f3 Link encap:Ethernet  HWaddr <span class="number">02</span>:<span class="number">42</span>:bc:f1:<span class="number">91</span>:<span class="number">09</span></div><div class="line">          inet addr:<span class="number">192.168</span><span class="meta">.100</span><span class="meta">.1</span>  Bcast:<span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>  Mask:<span class="number">255.255</span><span class="meta">.255</span><span class="meta">.0</span></div></pre></td></tr></table></figure>
<p>linux桥接接口与交换机的功能类似，因为它们将不同的接口连接到同一子网，并根据MAC地址转发流量。 我们将在下面看到，连接到网桥网络的每个容器将在docker主机上创建自己的虚拟接口，并且docker引擎将同一网络中的所有容器连接到同一个网桥接口，这将允许它们与彼此进行通信。 您可以使用<code>brctl</code>获取有关网桥状态的更多详细信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">brctl </span><span class="keyword">show </span>docker0</div><div class="line"><span class="keyword">bridge </span>name     <span class="keyword">bridge </span>id               STP enabled     interfaces</div><div class="line">docker0         <span class="number">8000</span>.<span class="number">02424488</span>bd75       no</div></pre></td></tr></table></figure>
<p>一旦我们有容器运行并连接到这个网络，我们将看到interfaces列下面列出的每个容器的接口。 并且在桥接器接口上运行流量捕获将允许我们看到同一子网上的容器之间的相互通信。</p>
<h4 id="Linux-虚拟网络接口-veth"><a href="#Linux-虚拟网络接口-veth" class="headerlink" title="Linux 虚拟网络接口(veth)"></a>Linux 虚拟网络接口(veth)</h4><p>容器网络模型（CNM）允许每个容器具有其自己的网络空间。 从容器内部运行<code>ifconfig</code>将显示容器内部的网络接口：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">run</span> <span class="bullet">-ti</span> <span class="attr">ubuntu:14.04</span> <span class="string">/bin/bash</span></div><div class="line"><span class="string">root@6622112b507c:/#</span></div><div class="line"><span class="string">root@6622112b507c:/#</span> <span class="string">ifconfig</span></div><div class="line"><span class="string">eth0</span>      <span class="string">Link</span> <span class="attr">encap:Ethernet</span>  <span class="string">HWaddr</span> <span class="number">02</span><span class="string">:42:ac:12:00:02</span></div><div class="line">          <span class="string">inet</span> <span class="attr">addr:172.18.0.2</span>  <span class="attr">Bcast:0.0.0.0</span>  <span class="attr">Mask:255.255.0.0</span></div><div class="line">          <span class="string">inet6</span> <span class="attr">addr:</span> <span class="attr">fe80::42:acff:fe12:2/64</span> <span class="attr">Scope:Link</span></div><div class="line">          <span class="string">UP</span> <span class="string">BROADCAST</span> <span class="string">RUNNING</span> <span class="string">MULTICAST</span>  <span class="attr">MTU:1500</span>  <span class="attr">Metric:1</span></div><div class="line">          <span class="string">RX</span> <span class="attr">packets:9</span> <span class="attr">errors:0</span> <span class="attr">dropped:0</span> <span class="attr">overruns:0</span> <span class="attr">frame:0</span></div><div class="line">          <span class="string">TX</span> <span class="attr">packets:6</span> <span class="attr">errors:0</span> <span class="attr">dropped:0</span> <span class="attr">overruns:0</span> <span class="attr">carrier:0</span></div><div class="line"><span class="attr">          collisions:</span><span class="number">0</span> <span class="attr">txqueuelen:0</span></div><div class="line">          <span class="string">RX</span> <span class="attr">bytes:766</span> <span class="string">(766.0</span> <span class="string">B)</span>  <span class="string">TX</span> <span class="attr">bytes:508</span> <span class="string">(508.0</span> <span class="string">B)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="string">lo</span>        <span class="string">Link</span> <span class="attr">encap:Local</span> <span class="string">Loopback</span></div><div class="line">          <span class="string">inet</span> <span class="attr">addr:127.0.0.1</span>  <span class="attr">Mask:255.0.0.0</span></div><div class="line">          <span class="string">inet6</span> <span class="attr">addr:</span> <span class="string">::1/128</span> <span class="attr">Scope:Host</span></div><div class="line">          <span class="string">UP</span> <span class="string">LOOPBACK</span> <span class="string">RUNNING</span>  <span class="attr">MTU:65536</span>  <span class="attr">Metric:1</span></div><div class="line">          <span class="string">RX</span> <span class="attr">packets:0</span> <span class="attr">errors:0</span> <span class="attr">dropped:0</span> <span class="attr">overruns:0</span> <span class="attr">frame:0</span></div><div class="line">          <span class="string">TX</span> <span class="attr">packets:0</span> <span class="attr">errors:0</span> <span class="attr">dropped:0</span> <span class="attr">overruns:0</span> <span class="attr">carrier:0</span></div><div class="line"><span class="attr">          collisions:</span><span class="number">0</span> <span class="attr">txqueuelen:0</span></div><div class="line">          <span class="string">RX</span> <span class="attr">bytes:0</span> <span class="string">(0.0</span> <span class="string">B)</span>  <span class="string">TX</span> <span class="attr">bytes:0</span> <span class="string">(0.0</span> <span class="string">B)</span></div></pre></td></tr></table></figure>
<p>然而，上面看到的eth0只能从那个容器中可用，而在Docker主机的外部，docker会创建一个与其对应的双虚拟接口，并作为到容器外的链接。 这些虚拟接口连接到上面讨论的桥接器接口，以便于在同一子网上的不同容器之间的连接。</p>
<p>我们可以通过启动连接到默认网桥的两个容器来查看此过程，然后查看docker主机上的接口配置。</p>
<p>在运行启动任何容器之前，docker0 桥接接口没有连接的接口：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="keyword">brctl </span><span class="keyword">show </span>docker0</div><div class="line"><span class="keyword">bridge </span>name     <span class="keyword">bridge </span>id               STP enabled     interfaces</div><div class="line">docker0         <span class="number">8000</span>.<span class="number">02424488</span>bd75       no</div></pre></td></tr></table></figure>
<p>然后我从<code>ubuntu:14.04</code> 镜像启动2个容器</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">a754719db594        ubuntu:<span class="number">14.04</span>        <span class="string">"/bin/bash"</span>         <span class="number">5</span> <span class="built_in">seconds</span> ago       Up <span class="number">4</span> <span class="built_in">seconds</span>                            zen_kalam</div><div class="line"><span class="number">976041</span>ec420f        ubuntu:<span class="number">14.04</span>        <span class="string">"/bin/bash"</span>         <span class="number">7</span> <span class="built_in">seconds</span> ago       Up <span class="number">5</span> <span class="built_in">seconds</span>                            stupefied_easley</div></pre></td></tr></table></figure>
<p>您能马上看到现在有两个接口连接到docker0网桥接口（每个容器一个）</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo <span class="keyword">brctl </span><span class="keyword">show </span>docker0</div><div class="line"><span class="keyword">bridge </span>name     <span class="keyword">bridge </span>id               STP enabled     interfaces</div><div class="line">docker0         <span class="number">8000</span>.<span class="number">02424488</span>bd75       no              veth2177159</div><div class="line">                                                        vethd8e05dd</div></pre></td></tr></table></figure>
<p>从其中一个容器ping到google，然后从docker主机对容器的虚拟接口进行流量捕获，将显示容器流量<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ docker exec a754719db594 ping google.com</div><div class="line">PING google.com (<span class="number">216.58</span><span class="meta">.217</span><span class="meta">.110</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</div><div class="line"><span class="number">64</span> bytes from iad23s42-<span class="keyword">in</span>-f110<span class="meta">.1e100</span>.net (<span class="number">216.58</span><span class="meta">.217</span><span class="meta">.110</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">48</span> time=<span class="number">0.849</span> ms</div><div class="line"><span class="number">64</span> bytes from iad23s42-<span class="keyword">in</span>-f110<span class="meta">.1e100</span>.net (<span class="number">216.58</span><span class="meta">.217</span><span class="meta">.110</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">48</span> time=<span class="number">0.965</span> ms</div><div class="line"><span class="symbol"></span></div><div class="line">ubuntu@swarm02:~$ sudo tcpdump -i veth2177159 icmp</div><div class="line"><span class="symbol">tcpdump:</span> verbose output suppressed, use -v <span class="keyword">or</span> -vv for full protocol decode</div><div class="line">listening on veth2177159, link-type EN10MB (Ethernet), capture size <span class="number">262144</span> bytes</div><div class="line"><span class="number">20</span>:<span class="number">47</span>:<span class="number">12.170815</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span> &gt; iad23s42-<span class="keyword">in</span>-f14<span class="meta">.1e100</span>.net: ICMP echo request, id <span class="number">14</span>, seq <span class="number">55</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">47</span>:<span class="number">12.171654</span> <span class="built_in">IP</span> iad23s42-<span class="keyword">in</span>-f14<span class="meta">.1e100</span>.net &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: ICMP echo reply, id <span class="number">14</span>, seq <span class="number">55</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">47</span>:<span class="number">13.170821</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span> &gt; iad23s42-<span class="keyword">in</span>-f14<span class="meta">.1e100</span>.net: ICMP echo request, id <span class="number">14</span>, seq <span class="number">56</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">47</span>:<span class="number">13.171694</span> <span class="built_in">IP</span> iad23s42-<span class="keyword">in</span>-f14<span class="meta">.1e100</span>.net &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: ICMP echo reply, id <span class="number">14</span>, seq <span class="number">56</span>, length <span class="number">64</span></div></pre></td></tr></table></figure></p>
<p>同样，我们可以从一个容器平到另一个容器。<br>首先，我们需要获取容器的IP地址，这可以通过在容器中运行<code>ifconfig</code>或使用<code>docker inspect</code>命令检查容器来完成：</p>
<figure class="highlight twig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="xml">$ docker inspect -f ' </span><span class="template-variable">&#123;&#123; <span class="name">range</span> .NetworkSettings.Networks &#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; .IPAddress &#125;&#125;</span><span class="xml"></span><span class="template-variable">&#123;&#123; end &#125;&#125;</span><span class="xml"> ' a754719db594 </span></div><div class="line">172.18.0.3</div></pre></td></tr></table></figure>
<p>然后我们从一个容器ping另一个容器</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker exec 976041ec420f ping <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span></div><div class="line">PING <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span> (<span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</div><div class="line"><span class="number">64</span> bytes from <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.070</span> ms</div><div class="line"><span class="number">64</span> bytes from <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.053</span> ms</div></pre></td></tr></table></figure>
<p>要从docker主机看到这个流量，我们可以在对应于容器的任何一个虚拟接口上捕获，或者我们可以在桥接口（在这个实例中为docker0）上捕获，显示所有的容器间通信子网：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo tcpdump -ni docker0 host <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.2</span> <span class="keyword">and</span> host <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span></div><div class="line"><span class="symbol">tcpdump:</span> verbose output suppressed, use -v <span class="keyword">or</span> -vv for full protocol decode</div><div class="line">listening on docker0, link-type EN10MB (Ethernet), capture size <span class="number">262144</span> bytes</div><div class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">37.990831</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.2</span> &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: ICMP echo request, id <span class="number">14</span>, seq <span class="number">200</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">37.990865</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span> &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.2</span>: ICMP echo reply, id <span class="number">14</span>, seq <span class="number">200</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">38.990828</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.2</span> &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span>: ICMP echo request, id <span class="number">14</span>, seq <span class="number">201</span>, length <span class="number">64</span></div><div class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">38.990866</span> <span class="built_in">IP</span> <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.3</span> &gt; <span class="number">172.18</span><span class="meta">.0</span><span class="meta">.2</span>: ICMP echo reply, id <span class="number">14</span>, seq <span class="number">201</span>, length <span class="number">64</span></div></pre></td></tr></table></figure>
<h5 id="定位一个容器的vet接口"><a href="#定位一个容器的vet接口" class="headerlink" title="定位一个容器的vet接口"></a>定位一个容器的vet接口</h5><p>没有直接的方法来找到docker主机上的哪个veth接口链接到容器内的接口，但是在各种docker论坛和github中讨论了几种方法。在我看来最简单的是以下（基于<a href="https://github.com/docker/docker/issues/20224" target="_blank" rel="external">这个</a>解决方案做了稍微的修改），这也取决于<code>ethtool</code>在容器中可访问</p>
<p>例如：我的系统上运行了3个容器</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">ccbf97c72bf5        ubuntu:<span class="number">14.04</span>        <span class="string">"/bin/bash"</span>         <span class="number">3</span> <span class="built_in">seconds</span> ago       Up <span class="number">3</span> <span class="built_in">seconds</span>                            admiring_torvalds</div><div class="line"><span class="number">77</span>d9f02d61f2        ubuntu:<span class="number">14.04</span>        <span class="string">"/bin/bash"</span>         <span class="number">4</span> <span class="built_in">seconds</span> ago       Up <span class="number">4</span> <span class="built_in">seconds</span>                            goofy_borg</div><div class="line"><span class="number">19743</span>c0ddf24        ubuntu:<span class="number">14.04</span>        <span class="string">"/bin/sh"</span>           <span class="number">8</span> minutes ago       Up <span class="number">8</span> minutes                            high_engelbart</div></pre></td></tr></table></figure>
<p>首先我运行如下命令来获得<code>peer_ifindex</code>号</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">exec</span> <span class="number">77</span><span class="string">d9f02d61f2</span> <span class="string">sudo</span> <span class="string">ethtool</span> <span class="bullet">-S</span> <span class="string">eth0</span></div><div class="line"><span class="string">NIC</span> <span class="attr">statistics:</span></div><div class="line"><span class="attr">     peer_ifindex:</span> <span class="number">16</span></div></pre></td></tr></table></figure>
<p>然后在docker主机上，通过<code>peer_ifindex</code>找到接口名称</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo ip link | grep <span class="number">16</span></div><div class="line"><span class="number">16</span>: veth7bd3604@if15: <span class="variable">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu <span class="number">1500</span> qdisc noqueue master docker0 <span class="keyword">state</span> UP mode DEFAULT <span class="keyword">group</span> <span class="keyword">default</span></div></pre></td></tr></table></figure>
<p>所以，在目前的情况下，接口名称是：<code>veth7bd3604</code></p>
<h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><p>Docker使用linux iptables来控制与它创建的接口和网络之间的通信。 Linux iptables由不同的表组成，但我们主要关注两个：<code>filter</code>和<code>nat</code>。过滤器是网络或接口的流量的安全规则表,用于允许或拒绝IP地址,而nat包含负责屏蔽IP地址或端口的规则。Docker使用nat允许桥接网络上的容器与docker主机之外的目的地进行通信（否则指向容器网络的路由必须在docker主机的网络中添加）</p>
<p><strong>iptables:filter</strong></p>
<p>iptables中的表由对应于处理docker主机上的数据包的不同条件或阶段的不同链组成。默认情况下，过滤器表具有3个链：用于处理到达主机并且去往同一主机的分组的输入链，用于发送到外部目的地的主机的分组的输出链，以及用于进入主机但具有目的地外部主机。每个链由一些规则组成，这些规则规定对分组采取一些措施（例如拒绝或接受分组）以及匹配规则的条件。 顺序处理规则，直到找到匹配项，否则应用链的默认策略。 也可以在表中定义自定义链。</p>
<p>要查看过滤器表中链的当前配置的规则和默认策略，可以运行<code>iptables -t filter -L</code>（或<code>iptables -L</code>，如果未指定表，则默认使用过滤器表）</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">$ sudo iptables -t filter -L</div><div class="line">Chain INPUT (policy <span class="keyword">ACCEPT</span>)</div><div class="line">target     prot opt source               destination</div><div class="line"><span class="keyword">ACCEPT</span>     tcp  <span class="comment">--  anywhere             anywhere             tcp dpt:domain</span></div><div class="line"><span class="keyword">ACCEPT</span>     udp  <span class="comment">--  anywhere             anywhere             udp dpt:domain</span></div><div class="line"><span class="keyword">ACCEPT</span>     tcp  <span class="comment">--  anywhere             anywhere             tcp dpt:bootps</span></div><div class="line"><span class="keyword">ACCEPT</span>     udp  <span class="comment">--  anywhere             anywhere             udp dpt:bootps</span></div><div class="line">Chain FORWARD (policy <span class="keyword">ACCEPT</span>)</div><div class="line">target     prot opt source               destination</div><div class="line">DOCKER-ISOLATION  <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DOCKER     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DOCKER     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DOCKER     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">ACCEPT</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">Chain OUTPUT (policy <span class="keyword">ACCEPT</span>)</div><div class="line">target     prot opt source               destination</div><div class="line">Chain DOCKER (<span class="number">3</span> references)</div><div class="line">target     prot opt source               destination</div><div class="line">Chain DOCKER-ISOLATION (<span class="number">1</span> references)</div><div class="line">target     prot opt source               destination</div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line">DROP       <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div><div class="line"><span class="keyword">RETURN</span>     <span class="keyword">all</span>  <span class="comment">--  anywhere             anywhere</span></div></pre></td></tr></table></figure>
<p>突出显示的是不同的链，以及每个链的默认策略（没有自定义链的默认策略）。 我们还可以看到Docker已经添加了两个自定义链：<code>Docker</code>和<code>Docker-Isolation</code>，并且在<code>Forward</code>链中插入了以这两个新链作为目标的规则。</p>
<p><strong><em>Docker-isolation chain</em></strong></p>
<p><code>Docker-isolation</code>包含限制不同容器网络之间的访问的规则。 要查看更多详细信息，请在运行<code>iptables</code>时使用<code>-v</code>选项</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sudo iptables -t filter -L -v</div><div class="line">….</div><div class="line">Chain DOCKER-ISOLATION (<span class="number">1</span> references)</div><div class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     <span class="keyword">out</span>     source               destination</div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  br-e6bc7d6b75f3 docker0  anywhere             anywhere</span></div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  docker0 br-e6bc7d6b75f3  anywhere             anywhere</span></div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  docker_gwbridge docker0  anywhere             anywhere</span></div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  docker0 docker_gwbridge  anywhere             anywhere</span></div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  docker_gwbridge br-e6bc7d6b75f3  anywhere             anywhere</span></div><div class="line">    <span class="number">0</span>     <span class="number">0</span> DROP       <span class="keyword">all</span>  <span class="comment">--  br-e6bc7d6b75f3 docker_gwbridge  anywhere             anywhere</span></div><div class="line"><span class="number">36991</span> <span class="number">3107</span>K <span class="keyword">RETURN</span>     <span class="keyword">all</span>  <span class="comment">--  any    any     anywhere             anywhere</span></div></pre></td></tr></table></figure>
<p>您可以在上面看到一些删除规则，阻止任何由docker创建的桥接接口之间的流量，从而确保容器网络不能通信。</p>
<p><strong><em>icc=false</em></strong></p>
<p>可以传递到<code>docker network create</code>命令的选项之一是<code>com.docker.network.bridge.enable_icc</code>，它代表容器间通信。 将此选项设置为<code>false</code>会阻止同一网络上的容器彼此通信。 这是通过在前向链中添加一个丢弃规则来实现的，该丢弃规则匹配来自与去往同一接口的网络相关联的桥接器接口的分组。</p>
<p>举个例子，我们用以下命令创建一个新的网络</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network create --driver bridge --subnet <span class="number">192.168</span><span class="number">.200</span><span class="number">.0</span>/<span class="number">24</span> --ip-range <span class="number">192.168</span><span class="number">.200</span><span class="number">.0</span>/<span class="number">24</span> -o <span class="string">"com.docker.network.bridge.enable_icc"</span>=<span class="string">"false"</span> no-icc-network</div></pre></td></tr></table></figure>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ ifconfig | grep 192.168.200 -B 1</div><div class="line">br-8e3f0d353353 Link encap:Ethernet  HWaddr 02:42:c4:6b:f1:40</div><div class="line">          inet addr:192.168.200.1  Bcast:0.0.0.0  Mask:255.255.255.0</div><div class="line"></div><div class="line">$ sudo iptables -t filter -S FORWARD</div><div class="line">-<span class="ruby">P FORWARD ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -j DOCKER-ISOLATION</span></div><div class="line">-<span class="ruby">A FORWARD -o br-<span class="number">8</span>e3f0d353353 -j DOCKER</span></div><div class="line">-<span class="ruby">A FORWARD -o br-<span class="number">8</span>e3f0d353353 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i br-<span class="number">8</span>e3f0d353353 ! -o br-<span class="number">8</span>e3f0d353353 -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -o docker<span class="number">0</span> -j DOCKER</span></div><div class="line">-<span class="ruby">A FORWARD -o docker<span class="number">0</span> -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i docker<span class="number">0</span> ! -o docker<span class="number">0</span> -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i docker<span class="number">0</span> -o docker<span class="number">0</span> -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -o br-e6bc7d6b75f3 -j DOCKER</span></div><div class="line">-<span class="ruby">A FORWARD -o br-e6bc7d6b75f3 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i br-e6bc7d6b75f3 ! -o br-e6bc7d6b75f3 -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i br-e6bc7d6b75f3 -o br-e6bc7d6b75f3 -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -o docker_gwbridge -j DOCKER</span></div><div class="line">-<span class="ruby">A FORWARD -o docker_gwbridge -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i docker_gwbridge ! -o docker_gwbridge -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -o lxcbr<span class="number">0</span> -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i lxcbr<span class="number">0</span> -j ACCEPT</span></div><div class="line">-<span class="ruby">A FORWARD -i docker_gwbridge -o docker_gwbridge -j DROP</span></div><div class="line">-<span class="ruby">A FORWARD -i br-<span class="number">8</span>e3f0d353353 -o br-<span class="number">8</span>e3f0d353353 -j DROP</span></div></pre></td></tr></table></figure>
<p><strong>iptables:nat</strong></p>
<p><code>NAT</code>允许主机更改数据包的IP地址或端口。在这种情况下,它用于屏蔽源IP地址来自docker网络（例如172.18.0.0/24子网中的主机），目的地为容器外，位于docker主机的IP地址之后的数据包。此功能由<code>com.docker.network.bridge.enable_ip_masquerade</code>选项控制，可以在<code>docker network create</code>（如果未指定，则默认为true）命令中使用。</p>
<p>你可以在iptables的nat表中看到此命令的效果</p>
<pre>
$ sudo iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL


Chain INPUT (policy ACCEPT)
target     prot opt source               destination


Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  anywhere            !127.0.0.0/8          ADDRTYPE match dst-type LOCAL


Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  172.18.0.0/16        anywhere
MASQUERADE  all  --  192.168.100.0/24     anywhere
MASQUERADE  all  --  172.19.0.0/16        anywhere
MASQUERADE  all  --  10.0.3.0/24         !10.0.3.0/24


Chain DOCKER (2 references)
target     prot opt source               destination
RETURN     all  --  anywhere             anywhere
RETURN     all  --  anywhere             anywhere
RETURN     all  --  anywhere             anywhere
</pre>

<p>在<code>postrouting</code>链中，您可以看到在与自己网络外部的任何主机通信时，通过应用伪装操作创建的所有docker网络。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>网桥网络在docker主机上具有对应的linux网桥接口，其作为layer2交换机，并且连接在同一子网上的不同容器。</li>
<li>容器中的每个网络接口在Docker主机上具有在容器运行时创建的对应虚拟接口。</li>
<li>桥接接口上来自Docker主机的流量捕获等效于在交换机上配置SPAN端口，可以在该网络上查看所有集群间通信。</li>
<li>在虚拟接口（veth- *）上来自docker主机的流量捕获将显示容器在特定子网上发送的所有流量</li>
<li>Linux iptables规则用于阻止不同的网络（有时网络中的主机）使用过滤器表进行通信。 这些规则通常添加在<code>DOCKER-ISOLATION</code>链中。</li>
<li>容器通过桥接接口与外部通信，其IP被隐藏在docker主机的IP地址后面。 这是通过向<code>iptables</code>中的<code>nat</code>表添加规则来实现的。</li>
</ul>
<h3 id="链接-资源"><a href="#链接-资源" class="headerlink" title="链接/资源"></a>链接/资源</h3><p><a href="https://github.com/docker/labs/tree/master/networking/concepts" target="_blank" rel="external"><strong>Docker networking concepts</strong></a></p>
<p><a href="https://www.youtube.com/watch?v=nXaF2d97JnE" target="_blank" rel="external"><strong>Deep dive into Docker 1.12 Networking</strong></a></p>
<p><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external"><strong>Docker container networking user guide</strong></a></p>
<p><a href="https://wiki.archlinux.org/index.php/Iptables#Tables" target="_blank" rel="external"><strong>Linux iptables overview</strong></a></p>
<p>原文作者： <a href="https://plus.google.com/111321614537507172826" target="_blank" rel="external">Abdul Kittana</a></p>
]]></content>
      
        <categories>
            
            <category> docker </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[博客搭建过程]]></title>
      <url>/2017/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="博客建设过程"><a href="#博客建设过程" class="headerlink" title="博客建设过程"></a>博客建设过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经历了一周的时间，总算把自己的Github博客搭建起来了，其中参考了很多模板，改动的地方也颇多，主要参考了MOxFIVE的主题，自己不是做前端的，希望改进的地方能给读者以很多启发。<br>　<br>　  本博客的搭建选择了现在很热门的<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a> + <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a> 的方式来搭建独立的个人博客。<br>详情参考：<a href="http://www.jianshu.com/p/f4dce0e76886" target="_blank" rel="external">hexo+github打造个人博客</a>　　</p>
]]></content>
      
        <categories>
            
            <category> 杂记 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
